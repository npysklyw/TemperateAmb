#define SW_BASE 0xFF200040
#define KEY_BASE 0xFF200050
#define TIMER_A9_BASE 0xFFFEC600
#define I2C0_BASE 0xFFC04000


// pointers to hardware
volatile I2Cn* const I2C_ptr = ( I2Cn* )I2C0_BASE;
volatile a9_timer *const timer_1 = (a9_timer *)TIMER_A9_BASE;
volatile int* const pushBtnInput = (int*)KEY_BASE;

#include <stdio.h>
#include <math.h>

//I2c structure for the DE10 I2C
//Code from the unit 9: Communications 
typedef struct _I2Cn
{
	// uses variables called 'pad' to align
	// needed registers in memory
		int control;			//0x00
		int target; 			//0x04
		int slave;				//0x08
		int pad0; 				//skip
		int data_cmd;			//0x10
		int std_scl_hcnt;		//0x14
		int std_scl_lcnt;		//0x18
		int fast_scl_hcnt;		//0x1C
		int fast_scl_lcnt;		//0x20
		int pad1;				//skip
		int pad2;				//skip
		int intr_status;		//0x2C
		int intr_mask;			//0x30		
		int raw_intr_status;	//0x34
		int rx_fifo_thr;		//0x38
		int tx_fifo_thr;		//0x3C
		int cmb_intr;			//0x40
		int rx_under_intr;		//0x44
		int rx_over_intr;		//0x48
		int tx_over_intr;		//0x4C
		int intr_read;			//0x50
		int tx_abort_intr;		//0x54
		int rx_done_intr;		//0x58
		int activity_intr;		//0x5C
		int stop_dtct_intr;		//0x60
		int start_dtct_intr;	//0x64
		int gen_call_intr;		//0x68
		int enable;				//0x6C
		int status;				//0x70
		int tx_fifo_lvl;		//0x74
		int rx_fifo_lvl;		//0x78
		int sda_hold;			//0x7C
		int tx_abort_src;		//0x80
		int gen_slave_nack;		//0x84
		int dma_control;		//0x88
		int dma_tx_lvl;			//0x8C
		int rx_data_lvl;		//0x90
		int sda_setup;			//0x94
		int ack_gen_call;		//0x98
		int enable_status;		//0x9C
		int ss_fs_supp;			//0xA0
} I2Cn;


// Structure for the timer
typedef struct _a9_timer
{
    int load;
    int count;
    int control;
    int status;
} a9_timer;

int season;
int count = 0;

struct RGB {
    unsigned char R;
    unsigned char G;
    unsigned char B;
};

//Suppose we have a date value, we need to convert this date to a season
//This table will contain various seasons
const unsigned short seasonalTable[4][12] =
  {{5,7,9,10,11,13,15,16,17,18,19,20},
  {16,17,18,19,20,21,22,23,24,25,26,30},
  {7,8,9,10,13,14,15,16,17,18,19,20},
  {-25,-20,-15,-13,-10,-8,-4,-1,0,1,3,5},
  }; //try to do 

//Convert the AS621 digital hex value to a celsius value
int getTemperature() {

    //Get temeprature as a hexadecimal value
    int hexTemp = getHexTemp();

    //Manual gives a conversion formula
    //0.0078125 * Hex value = complement
    //negative is (Hex value - 1)
    //Calcualte celsius using this

    //Use formula
    int celsius = hexTemp*0.0078125;

    //Return celsius value
	return celsius;
}

//Want to get internal data register value
int getHexTemp() {
    //First it says in manual to write to index register
    //Write to index register
    I2C_ptr->data_cmd = 0x46 + 1;

    //Write TVAL registervalue to let device know we want this
    I2C_ptr->data_cmd = 0x0;

    //Wait for data to arrive
    while ( I2C_ptr->rx_fifo_lvl == 0 );	
   
    int tempHex;

 //Get first half of bits from the tempval register
    tempHex = I2C_ptr->data_cmd;

    //Wait for next bits to arrive
    while ( I2C_ptr->rx_fifo_lvl == 0 );	

     //Get net half of bits from the tempval register, shift temp to properly reflect theri value
    tempHex = tempHex + (I2C_ptr->data_cmd << 8);

    //Return combined lsb,msbs
    return tempHex;

}

long decimalToBinary(int decimalnum)
{
    long binarynum = 0;
    int rem, temp = 1;

    while (decimalnum!=0)
    {
        rem = decimalnum%2;
        decimalnum = decimalnum / 2;
        binarynum = binarynum + rem*temp;
        temp = temp * 10;
    }
    return binarynum;
}

//Init I2C on DE10
void init_I2C()
{

    //Enable the I2C pin, disable the I2C controller
	I2C_ptr->enable = 2;
	
	//Looking at enable status until bit 0 is cleard
	while ( I2C_ptr->enable_status & 0x1 );
	

	//Here I set the appropriate control bits
	I2C_ptr->control = 0b01101101;

	//Set the specific slave address for the AS621
	I2C_ptr->target = 0x46;

	//Not 100% sure about this
	// set count for high-period of clock
	I2C_ptr->fast_scl_hcnt = 90;
	// set count for low-period of clock
	I2C_ptr->fast_scl_lcnt = 160;

	//Enable the I2C controller after it has been configured for the DE10
	I2C_ptr->enable = 1;


	//Wait until the status register is set to 1 which would mean enabled
	while (( I2C_ptr->enable_status & 0x1 ) == 0 );	
}

//Initalize the AS621 device
void initAS621() {

    //Do required initialization
    //Step One as said in manual, START condition is generated by master by pulling SDA from lopgic high to low, while SCL is kept at high
    //Pull data line from high to low
    //Connetion 3 is chosen
	I2C_ptr->data_cmd = 0;

    //Slave address byte fro device  is completed with 9th bit to itnegate a read 1 or write 0
	//Byte + 1 to indicate a read
	I2C_ptr->data_cmd = 0x46 + 0;

}

//Return a season based on push button input
int getSeason(){

    //Get the current value of the push buttons
    volatile int inputValue = *pushBtnInput;
        
    //Return appropriate season for the push buttons 1-4
    switch(inputValue){
        case 1:
            return 0;
            break;
        case 2:
            return 1;
            break;
        case 4:
            return 2;
            break;
        case 8:
            return 3;
            break;
    }
	
    //If not a selected choose the season Summer
	return 1;
    
}




//Return an RGB value appropriate to a specific seasonal input(0->3) in combination with a temperature input
int getRGB(int temp,int season) {
	
    //Define a struture to hold RGB values
    struct RGB *rgb = malloc(12*sizeof(struct RGB));

    //The structure is 12 size
    //There are 12 temperature settings avaliable
    //0 is white and is coldest temperature for that season
    //12 is red, and is the hottest temperature for the season
    //I personally picked each colour code
	rgb[0].R = 255;
    rgb[0].G = 230;
    rgb[0].B = 204;

    rgb[1].R = 255;
    rgb[1].G = 217;
    rgb[1].B = 179;
    
    rgb[2].R = 255;
    rgb[2].G = 204;
    rgb[2].B = 153;
    
    rgb[3].R = 255;
    rgb[3].G = 191;
    rgb[3].B = 128;
    
    rgb[4].R = 255;
    rgb[4].G = 179;
    rgb[4].B = 102;
    
    rgb[5].R = 255;
    rgb[5].G = 166;
    rgb[5].B = 77;
    
    rgb[6].R = 255;
    rgb[6].G = 153;
    rgb[6].B = 51;
    
    rgb[7].R = 255;
    rgb[7].G = 140;
    rgb[7].B = 26;
    
    rgb[8].R = 255;
    rgb[8].G = 128;
    rgb[8].B = 0;
    
    rgb[9].R = 230;
    rgb[9].G = 115;
    rgb[9].B = 0;
    
    rgb[10].R = 204;
    rgb[10].G = 102;
    rgb[10].B = 0;
    
    rgb[11].R = 204;
    rgb[11].G = 0;
    rgb[11].B = 51;
    
    rgb[12].R = 204;
    rgb[12].G = 0;
    rgb[12].B = 0;
    
    //Similar operation to getTemperature, compare if the current temperature is in bounds of two adjacent
	unsigned char near1=0, near2=0;
	int index = 0;

	//Loop through through the relevant seasonal RGB array
    //The seasonal temperature table defined above, the relevant row is seleceted using the season function input
	for (int i = 1; i < 12; i++)
	{
		//Find closest temperature value index
		if ((seasonalTable[season][i]>=temp) && (temp>=seasonalTable[season][i+1]) ) {

            //Once again, chose a indice that is closest to current temprerature
			near1 = seasonalTable[season][i]-temp;
			near2 = temp-seasonalTable[season][i+1];
			if(near1<near2) index=i;
			else  index=i+1;
		}
	} 

    //Index now has indice that will be the best suited colour to the seasonal temperature.

	//Return the RGB value at this index as #,#,#
    return rgb[index].R,rgb[index].G,rgb[index].B;
	
}

//General tranfer write to index register

// Initialize the timer
void initTimer()
{

    //Set the time interval to 10 seconds
    int interval = 1000000000;

    //Put this into the timer laod register
    timer_1->load = interval;

    //Set control register, start timer
    timer_1->control = 3 + (1 << 8);

    //Set the status to 1 to reset timeout flag
    timer_1->status = 1;
}

// Check if the timer has timed out
void checkTimeOut()
{

    //Check for the timeout flag to show
    if (timer_1->status == 1)
    {


        //Set the current RGB value of some device to new one based on temperature, season
		setColour(getRGB(getTemperature(),season));

        //Reset the timer using the init interval function
        initTimer();
    }
}




//This method is very dependant on what peripheral is used
//The hope is to use the rgb values to write a specific sequence of lights to be on
int setColour(r,g,b) {

	//We would conduct writing of generated RGB values to the specific bulb peripheral here
    //ATM we have a skelton method though to show where this would happen
	 printf("Red Value: %ld \n", decimalToBinary(r));
	 printf("Green Value: %ld \n", decimalToBinary(g));
	 printf("Blue Value: %ld \n", decimalToBinary(g));

}


int main(void)
{
    //Get the current season
	season = getSeason();
	
    //Initialize the I2C controller for AS621
	init_I2C();

    //Initialize the AS621 slave device for temperature I2C communication
    initAS621();


    //Start timer
    initTimer();
	

	while(1) {	

        //Continiously check the timeout
        //Update the light if interval of 10 seconds reached
		checkTimeOut();
	
	}

}		

